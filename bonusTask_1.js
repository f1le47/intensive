Promise.resolve()
  .then(() => console.log("a: 1")) // (3)
  .then(() => {
    setTimeout(() => console.log("timeout 2")); // (8)
    console.log("a: 2"); // (4)
  })
  .then(() => {
    setTimeout(() => console.log("timeout 3")); // (9)
    console.log("a: 3"); // (6)
  });

new Promise((res, rej) => {
  console.log("b"); // (1)
  rej(new Error("123"));
})
  .then(console.log("b 1")) // (2)
  .then(
    () => console.log("b 2"),
    () => console.log("b") // (5)
  )
  .catch(() => console.log("b 3"))
  .then(() => console.log("b 4")); // (7)

// Сначала выполняется Promise.resolve(), который вызывает then и отправляет его callback в микротаски,
// и так как мы отдали callback в микротаски выполнение приостанавливается.

// Далее переходим к строчке 12, где создаем промис, в котором тело функции выполняется синхронно, переходим к строчке 13 и отправляем лог в callstack,
// где он сразу выполняется (1). После чего reject'им ошибку со значением "123". Вызывается then на 17 строчке и внутри него есть log, который мы вызываем,
// в консоле появляется b 1 (2), далее log возвращает undefined, поэтому then видит, что это не callback функция и пробрасывает reject дальше.

// Теперь eventloop проверяет callstack, видит, что он пустой и переходит к микротаскам. Там находится callback от then'а на строчке 2, выводит в консоль a 1 (3)
// и вызывает следующий по цепочке then (строка 3), его callback отправляется в микротаски.

// Выполнение кода приостанавливается и переходит на строку 17, где вызывает then, там мы видим, что есть вторая callback функция, которая обработает reject
// callback отправляет в микротаски

// Теперь eventloop видит, что callstack пустой и переходит к микротаскам, там находятся callback then'а со строчки 3 и callback then'а со строчки 17
// Он выполняет их в порядке очереди:
// callback then'а со строчки 3: выполняется setTimeout, который отдает callback функцию в WEB API, которая в последствии передает ее в макротаски,
// после чего выполняется log (a: 2) (4). Затем вызывается следующий then (строка 7) и его callback отдается в микротаски
// После этого, eventloop вызывает callback then'а со строчки 17 - мы получаем в консоли b (5) и вызываем следующий then (строка 7), callback которого уходит в микротаски.
// (catch пропускается, так как не принимает fulfilled статус)

// Теперь eventloop переходит к следующей микротаске, там у нас callback then'а со строчки 7, timeout отдает callback в WEB API, потом выполняет log (a: 3) (6)
// Так как цепочка then'ов закончилась, новых callback'ов в микротасках не добавляется.

// Осталась последняя микротаска в eventloop'е, он передает callback в callstack, где выполняется log(b 4) (7).

// И так как callstack пустой, очередь микротасок пуста, eventloop переходит к макротаскам:
// callback функция первого timeout передается первой, так как первее попала в макротаски, выполняется log(timeout 2) (8)
// После чего eventloop снова смотрит есть ли что-то в callstack'е и микротасках (так как за один "тик", выполняется только одна микротаска), там пусто,
// поэтому eventloop передает последнюю макротаску в callstack, где и происходит log(timeout 3) (9)